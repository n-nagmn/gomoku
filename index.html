<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>五目並べ (PHP + DB)</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
        }
        h1 {
            color: #333;
        }
        #game-info {
            font-size: 1.2em;
            margin: 10px;
            min-height: 2em;
        }
        #board-container {
            /* 盤面全体のサイズ */
            width: 600px;
            height: 600px;
            display: grid;
            /* 15x15のグリッドを作成 */
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            
            /* 全体の外枠だけ線を引く */
            border: 2px solid #333;
            background-color: #d2b48c; /* 碁盤の色 */
            box-shadow: 5px 5px 15px rgba(0,0,0,0.3);
        }

        .cell {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            position: relative;
            cursor: pointer; /* クリックできる感を出す */
        }
        
        /* 横線 (各セルの真ん中を貫く) */
        .cell::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            background-color: #333;
            z-index: 0; /* 石の下に表示 */
        }

        /* 縦線 (各セルの真ん中を貫く) */
        .cell::after {
            content: "";
            position: absolute;
            left: 50%;
            top: 0;
            height: 100%;
            width: 1px;
            background-color: #333;
            z-index: 0;
        }

        /* 一番上の行：縦線は上半分を消す（中心から下へ） */
        .cell:nth-child(-n+15)::after {
            top: 50%;
            height: 50%;
        }
        /* 一番下の行：縦線は下半分を消す（中心から上へ） */
        .cell:nth-last-child(-n+15)::after {
            height: 50%;
        }
        /* 一番左の列：横線は左半分を消す（中心から右へ） */
        .cell:nth-child(15n+1)::before {
            left: 50%;
            width: 50%;
        }
        /* 一番右の列：横線は右半分を消す（中心から左へ） */
        .cell:nth-child(15n)::before {
            width: 50%;
        }

        /* --- 石のデザイン --- */
        
        .cell:hover {
            background-color: rgba(255, 255, 255, 0.2); 
        }

        .stone {
            width: 90%;
            height: 90%;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 2px 2px 4px rgba(0,0,0,0.5), inset -3px -3px 5px rgba(0,0,0,0.5), inset 3px 3px 5px rgba(255,255,255,0.5);
            z-index: 1;
        }

        .player1 {
            background-color: #111; /* 黒石 */
            /* 黒石の光沢 */
            background: radial-gradient(circle at 30% 30%, #555, #000);
        }
        .player2 {
            background-color: #fff; /* 白石 */
            /* 白石の陰影 */
            background: radial-gradient(circle at 30% 30%, #fff, #ddd);
        }

        #start-button {
            font-size: 1.2em;
            padding: 10px 20px;
            margin-top: 15px;
            cursor: pointer;
        }
        #start-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>

    <h1>五目並べ</h1>
    <div id="game-info"></div>
    <div id="board-container"></div>
    <button id="start-button">ゲームを探す</button>

    <script>
        const BOARD_SIZE = 15;
        const boardContainer = document.getElementById('board-container');
        const infoDisplay = document.getElementById('game-info');
        const startButton = document.getElementById('start-button');
        
        // 1. クライアント固有のIDをセッションストレージで管理
        let myPlayerId = 'player_' + Date.now() + Math.floor(Math.random() * 10000);

        let gameState = {
            game_id: null,
            my_player_id: myPlayerId,
            my_role: null, // "player_1" or "player_2"
            player_1_id: null,
            current_turn_id: null,
            status: "init"
        };
        
        let pollingInterval = null;

        // 1. 盤面(セル)の初期化
        function initializeBoard() {
            boardContainer.innerHTML = '';
            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    boardContainer.appendChild(cell);
                }
            }
        }
        
        // 2. 盤面の描画 (サーバーからの情報に基づいて)
        function drawBoard(moves) {
            // 既存の石をすべてクリア
            document.querySelectorAll('.stone').forEach(stone => stone.remove());
            
            // サーバーからの石のリストを描画
            moves.forEach(move => {
                const cell = document.querySelector(`.cell[data-x='${move.x_coord}'][data-y='${move.y_coord}']`);
                if (cell) {
                    const stone = document.createElement('div');
                    stone.classList.add('stone');
                    // P1のID (gameState.player_1_id) と比較して色分けする
                    const playerClass = (move.player_id === gameState.player_1_id) ? 'player1' : 'player2';
                    stone.classList.add(playerClass);
                    cell.appendChild(stone);
                }
            });
        }
        
        // 3. 情報表示の更新
        function updateInfo() {
            if (gameState.status === 'waiting') {
                infoDisplay.textContent = `ゲームID: ${gameState.game_id} | 対戦相手を待っています...`;
            } else if (gameState.status === 'playing') {
                const roleName = (gameState.my_role === 'player_1') ? '黒 (P1)' : '白 (P2)';
                if (gameState.current_turn_id === gameState.my_player_id) {
                    infoDisplay.textContent = `あなたの番です (${roleName})`;
                } else {
                    infoDisplay.textContent = `相手の番です (${roleName})`;
                }
            } else if (gameState.status === 'finished') {
                if (gameState.winner_id === gameState.my_player_id) {
                    infoDisplay.textContent = "あなたの勝利です！";
                } else {
                    infoDisplay.textContent = "あなたの敗北です...。";
                }
                clearInterval(pollingInterval); // ゲーム終了なのでポーリング停止
            }
        }

        // 4. API: ゲームを探す
        startButton.addEventListener('click', async () => {
            try {
                // POSTメソッドで自分のIDを送る
                const response = await fetch('api_find_game.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ my_player_id: gameState.my_player_id })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.error) throw new Error(data.error);
                
                gameState.game_id = data.game_id;
                gameState.my_role = data.role;
                
                startButton.disabled = true;
                startButton.textContent = "ゲームに参加しました";
                
                // ポーリングを開始
                startPolling();
                
            } catch (err) {
                infoDisplay.textContent = "エラー: " + err.message;
            }
        });

        // 5. API: ポーリング
        function startPolling() {
            if (pollingInterval) clearInterval(pollingInterval);
            fetchState(); 
            pollingInterval = setInterval(fetchState, 2000);
        }
        
        async function fetchState() {
            if (!gameState.game_id) return;
            
            try {
                const response = await fetch(`api_get_state.php?game_id=${gameState.game_id}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                if (data.error) throw new Error(data.error);

                gameState.status = data.status;
                gameState.current_turn_id = data.current_turn_id;
                gameState.winner_id = data.winner_id;
                gameState.player_1_id = data.player_1_id; 
                
                drawBoard(data.moves);
                updateInfo();
                
            } catch (err) {
                infoDisplay.textContent = "ポーリングエラー: " + err.message;
                clearInterval(pollingInterval);
            }
        }
        
        // 6. API: 石を置く
        boardContainer.addEventListener('click', async (e) => {
            // クリックしたのがセル以外、または自分のターンでなければ何もしない
            if (!e.target.classList.contains('cell')) return;
            if (gameState.status !== 'playing' || gameState.current_turn_id !== gameState.my_player_id) {
                return;
            }
            
            // 既に石が置かれていないかチェック
            if (e.target.querySelector('.stone')) {
                infoDisplay.textContent = "そこには既に石があります";
                return;
            }
            
            const x = parseInt(e.target.dataset.x, 10);
            const y = parseInt(e.target.dataset.y, 10);
            
            try {
                const response = await fetch('api_place_move.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        game_id: gameState.game_id,
                        player_id: gameState.my_player_id,
                        x: x,
                        y: y
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.error) {
                    infoDisplay.textContent = `エラー: ${result.error}`;
                    return;
                }
                
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                    fetchState();
                    pollingInterval = setInterval(fetchState, 2000);
                }
                
            } catch (err) {
                infoDisplay.textContent = "着手エラー: " + err.message;
            }
        });

        // 初期化
        initializeBoard();

    </script>
</body>
</html>